#+title Emacs from scratch configuration
#+DESCRIPTION: Jorge's custom Emacs config.
#+STARTUP: showeverything
#+Options: toc:2
#+PROPERTY: header-args:emacs-lisp :tangle ./my-jupyter-utils.el


A few utilities to interact with external jupyter kernels. Most of this code was taken from [[https://sqrtminusone.xyz/posts/2021-05-01-org-python/][this website]]. All code and text is taken from there except where explicitly stated.

* Table of contents :toc:
- [[#change-environment-with-anaconda][Change environment with anaconda]]
- [[#use-an-external-kernel][Use an external kernel]]
  - [[#some-automation][Some automation]]
  - [[#cleanup][Cleanup]]
- [[#provide][Provide]]

* Change environment with anaconda

emacs-jupyter will always use the Python kernel found on startup. So if you switch to a new environment, the code will still be running in the old one, which is not too convenient.

Fortunately, to fix that we have only to force the refresh of Jupyter kernelspecs:

#+begin_src emacs-lisp

(defun my/jupyter-refresh-kernelspecs ()
  "Refresh Jupyter kernelspecs"
  (interactive)
  (jupyter-available-kernelspecs t))

#+end_src

In order to change environment, we use conda.el's ~(conda-env-activate "env-name")~. Here's my attempt at a function that does that (written by me)

#+begin_src emacs-lisp

(defun my/jupyter-change-env (env)
  "Change anaconda environment"
  (interactive)
  (my/jupyter-refresh-kernelspecs)
  (conda-env-activate env))

#+end_src

* Use an external kernel

To start a Jupyter kernel, run the following command in the environment and path you need:

#+begin_src bash

jupyter kernel --kernel=python

#+end_src

After the kernel is launched, write the path to the connection file into the =:session= header and press =C-c C-c= to refresh the setup:

#+begin_src 

#+PROPERTY: header-args:python :session /home/pavel/.local/share/jupyter/runtime/kernel-e770599c-2c98-429b-b9ec-4d1ddf5fc16c.json

#+end_src

Now python source blocks should be executed in the kernel.

To open a REPL, run ~M-x jupyter-connect-repl~ and select the given JSON. Or launch a standalone REPL like this:

#+begin_src bash

jupyter qtconsole --existing kernel-e770599c-2c98-429b-b9ec-4d1ddf5fc16c.json

#+end_src

Executing a piece of code in the REPL allows proper debugging, for instance with
=%pdb= magic. Also, Jupyter QtConsole generally handles large outputs better and even allows certain kinds of rich output in the REPL.

** Some automation

Now automate this process

#+begin_src emacs-lisp

(defun my/get-open-ports ()
  "Get the open ports on the system"
  (mapcar
   #'string-to-number
   (split-string (shell-command-to-string "ss -tulpnH | awk '{print $5}' | sed -e 's/.*://'") "\n")))

#+end_src

Then, list the available kernel JSONs:

#+begin_src emacs-lisp

(setq my/jupyter-runtime-folder (expand-file-name "~/.local/share/jupyter/runtime"))

(defun my/list-jupyter-kernel-files ()
  "List available jupyter kernel JSONs"
  (mapcar
   (lambda (file) (cons (car file) (cdr (assq 'shell_port (json-read-file (car file))))))
   (sort
    (directory-files-and-attributes my/jupyter-runtime-folder t ".*kernel.*json$")
    (lambda (x y) (not (time-less-p (nth 6 x) (nth 6 y)))))))
    
#+end_src

And query the user for a running kernel:

#+begin_src emacs-lisp

(defun my/select-jupyter-kernel ()
  "Query the user for a running kernel"
  (let ((ports (my/get-open-ports))
        (files (my/list-jupyter-kernel-files)))
    (completing-read
     "Jupyter kernels: "
     (seq-filter
      (lambda (file)
        (member (cdr file) ports))
      files))))

#+end_src

After which we can use the my/select-jupyter-kernel function however we want:

#+begin_src emacs-lisp

(defun my/insert-jupyter-kernel ()
  "Insert a path to an active Jupyter kernel into the buffer"
  (interactive)
  (insert (my/select-jupyter-kernel)))

(defun my/jupyter-connect-repl ()
  "Open emacs-jupyter REPL, connected to a Jupyter kernel"
  (interactive)
  (jupyter-connect-repl (my/select-jupyter-kernel) nil nil nil t))

(defun my/jupyter-qtconsole ()
  "Open Jupyter QtConsole, connected to a Jupyter kernel"
  (interactive)
  (start-process "jupyter-qtconsole" nil "setsid" "jupyter" "qtconsole" "--existing"
                 (file-name-nondirectory (my/select-jupyter-kernel))))

#+end_src

The first function, which simply inserts the path to the kernel, is meant to be used on the =:session= header. One can go even further and locate the header automatically, but that’s an idea for next time.

The second one opens a REPL provided by emacs-jupyter. The =t= argument is necessary to pop up the REPL immediately.

The last one launches Jupyter QtConsole. =setsid= is required to run the program in a new session, so it won’t close together with Emacs.

** Cleanup

I’ve also noticed that there are JSON files left in the runtime folder whenever the kernel isn’t stopped correctly. So here is a cleanup function.

#+begin_src emacs-lisp

(defun my/jupyter-cleanup-kernels ()
  "Cleanup JSON files left when kernel isn't stopped correctly"
  (interactive)
  (let* ((ports (my/get-open-ports))
         (files (my/list-jupyter-kernel-files))
         (to-delete (seq-filter
                     (lambda (file)
                       (not (member (cdr file) ports)))
                     files)))
    (when (and (length> to-delete 0)
               (y-or-n-p (format "Delete %d files?" (length to-delete))))
      (dolist (file to-delete)
        (delete-file (car file))))))
        
#+end_src

* Provide

#+begin_src emacs-lisp
(provide 'my-jupyter-utils)
#+end_src
